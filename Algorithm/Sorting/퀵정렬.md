# 퀵정렬

## 특징

- 분할정복(Divide and Conquer) 기법이다. 따라서, 재귀적으로 동작한다.
- 매번 한 원소(pivot)의 올바른 위치를 찾아준다. 원소의 올바른 위치란 그 원소보다 앞에 있는 것들은 그보다 작고, 뒤에 있는 것들은 그보다 크다면 올바른 위치이다.
- 매번 올바른 위치를 찾고 분할하여 이를 반복하여 모든 원소를 정렬하도록 하는 알고리즘.




### 시간복잡도

- 평균 : O(nlogn)
  - 보통 pivot을 선택하고 분할하면 평균적으로 총 logn 번 반복하게 된다. n개의 element를 보는 것 O(n)을 logn번 반복하니 O(logn)  결국 O(nlogn)
- 최선 : O(nlogn)
  - 매번 최선의 pivot을 선택할 경우 정확히 이등분으로 배열을 분할하게 되어 총 logn 번 반복한다. n개의 element를 보는 것 O(n)을 logn번 반복하니 O(logn)  결국 O(nlogn)
- 최악 : O(n^2)
  - 매번 최악의 pivot을 선택할 경우 분할이 안되어 총 n 번 반복한다. n개의 element를 보는 것 O(n)을 n번 반복하니 O(n)  결국 O(n^2)
  - ex) 오름차순으로 정렬해야되는데 이미 내림차순으로 정렬되어 있는 경우 
  - pivot을 앞에 3개 중에 크기가 중간인 것으로 선택한다거나 랜덤하게 선택한다거나 이번 배열의 중간값과 첫번째값 위치를 변경해서 한다거나 등의 방법으로 개선할 수 있다. 
  - 하지만 확실한 방법은 아니다.  


### 장점

- 시간이 빠르다. 매번 pivot을 제외한 원소들을 확인하기 때문에 다른 O(nlogn) 정렬 알고리즘보다 아주 좀 더 빠르다. 
- 제자리 정렬(in-place sorting)
  - 또 다른 대표적인 O(nlogn) 정렬 기법인 (하이퍼링크)합병정렬과는 다르게 추가적인 메모리를 소모하지 않는다.



### 단점

- 시간복잡도가 항상 일정하지 않다. 최악의 경우에는 O(n^2)가 되어버리고 만다.
- 불안정 정렬(Unstable Sort)
   ex)
                       ↓                                ↓                               
  - pivot이 6 일때,    8 8 8 8 ...  2  3       바꾼다.   3 8 8 8 ... 2  8    
                                       ↑                                ↑
               ↓                               ↓ 
  - 다음은   3 8 8 8 ... 2  8     바꾼다.    3 2 8 8 ... 8  8
                         ↑                               ↑                                            
  - 기존의 8 원소의 순서가 반대로 되어 정렬된다. 즉, 같은 키 값을 가진 원소의 원래 순서가 유지되지 않는다.




## 원리

1. 배열 중 하나의 원소를 고른다. 이를 pivot이라고 하고 보통 가장 첫 번째 원소를 pivot으로 사용한다. 
2. 왼쪽 포인터(ptr1)는 왼쪽 끝에서 시작하고 오른쪽 포인터(ptr2)는 오른쪽 끝에서 시작하여 서로를 향해 간다.
3. 이때, 왼쪽 포인터는 pivot 보다 작은 값이면 다음 칸으로 또 나아가고(ptr1 ++), 만약 pivot 보다 더 큰 값이면 멈춘다.
   오른쪽 포인터는 pivot 보다 큰 값이면 다음칸으로 또 나아가고(ptr2 --), 만약 pivot 보다 더 작은 값이면 멈춘다.
4. 두 포인터가 멈추었으면 두 포인터의 값을 서로 바꿔준다.
5. 왼쪽 포인터와 오른쪽 포인터가 만날때까지 위의 과정을 반복해준다. (ptr1 > ptr2)
6. 두 포인터 사이에 pivot을 넣어주고 pivot의 좌우로 분할하여 이러한 과정을 재귀적으로 반복해준다.




## 

