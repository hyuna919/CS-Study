# **삽입정렬**

## 1.원리

1. 2번째 원소부터 시작
2. 앞을 비교
3. 지정된 위치에 삽입 -- 사이에 값이 들어간다

![image-20210928202353416](C:\Users\hha97\AppData\Roaming\Typora\typora-user-images\image-20210928202353416.png)

---- 노란줄 : 시작위치 표시



## 2.공간복잡도

- 최선 : O(N)
- 최악 : O(N^2)
  - 역으로 배치되어 있는 경우 (n-1)+(n-2)+ ... +2 + 1 ==> n(n-1)/2

![자료구조론 11장 정렬(sort). - ppt download](https://slidesplayer.org/slide/14956479/91/images/27/%EC%82%BD%EC%9E%85+%EC%A0%95%EB%A0%AC+%EC%B5%9C%EC%84%A0%EC%9D%98+%EA%B2%BD%EC%9A%B0%3A+%EC%9E%85%EB%A0%A5+%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B0%80+%EC%9D%B4%EB%AF%B8+%EC%A0%95%EB%A0%AC%EB%90%98%EC%96%B4+%EC%9E%88%EC%9D%8C+%EC%B5%9C%EC%95%85%EC%9D%98+%EA%B2%BD%EC%9A%B0%3A+%EC%9E%85%EB%A0%A5+%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B0%80+%EC%97%AD%EC%88%9C%EC%9C%BC%EB%A1%9C+%EC%A0%95%EB%A0%AC%EB%90%98%EC%96%B4+%EC%9E%88%EC%9D%8C.jpg)



## 3. 장점

1. 알고리즘이 단순하다.
2. 원소가 이미 정렬되어 있을 경우 매우 효율적이다.
   1. 모두 정렬되어 있는 배열을 삽입 삭제하는 경우, 현실적으로 최고의 정렬 알고리즘이다.
   2. 이유 ) 탐색을 제외한 오버헤드가 매우 적기 때문
3. 안정 정렬
   1. 삽입정렬 = 제자리 정렬 알고리즘 = 안정 정렬
   2. **제자리 정렬 알고리즘** : swap을 위한 공간 외에 추가적인 저장공간이 필요 없는 알고리즘
   3. 즉, 입력한 데이터 공간에서 정렬하는 방법
   4. **안정 정렬** : 데이터가 들어온 순서가 유지된다.
   5. 즉, 정렬되지 않은 것들도 정렬 후에 유지되는가
4. 선택정렬, 버블정렬과 같은 O(n^2)알고리즘에 비해 상대적으로 빠르다.

## 4. 단점

1. 평균과 최악의 시간복잡도가  O(n^2)이므로 비효율적이다.
2. 선택정렬, 버블정렬과 마찬가지로 배열길이가 길어질수록 비효율적이다.







