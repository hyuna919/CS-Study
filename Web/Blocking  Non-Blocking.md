# **Blocking / Non-Blocking **

함수 A, B가 있고, A 안에서 B를 호출했다고 가정.

호출한 함수 (A), 호출된 함수 (B)

현재 B가 호출되면서 B는 자신의 일을 진행해야 한다. (제어권이 B에게 주어진 상황)

**블록/논블록은 호출된 함수가 호출한 함수에게 제어권을 건네주는 유무의 차이**

**Blocking 블록** : 함수 B는 내 할 일을 다 마칠 때까지 제어권을 가지고 있는다. A는 B가 다 마칠 때까지 기다려야 한다.  (일을 마치고 제어권 리턴)

**Non-Blocking** 논블록 : 함수 B는 할 일을 마치지 않았어도 A에게 제어권을 바로 넘겨준다.  A는 B를 기다리면서도 다른 일을 진행할 수 있다.  (일을 시작할 때 바로 제어권 리턴)



# **Synchronous / Asynchronous**

함수 B의 수행 결과나 종료 상태를 A가 신경쓰고 있는가

**Synchronous 동기** : 함수 A는 함수 B가 일을 하는 중에 기다리면서, 현재 상태가 어떤지 계속 체크한다.

**Asynchronous 비동기** : 함수 B의 수행 상태를 B 혼자 직접 신경쓰면서 처리한다. (callback)

​										요청에 대한 처리완료 여부에 관련없이 다음 작업 진행

​										이후에 운영체제에서 처리완료여부를 알려주고 응답



비동기는 callback이 오기 전까지는 호출한 함수는 신경쓰지 않고 다른 일을 할 수 있다.





![image-20211006205124162](C:\Users\hha97\AppData\Roaming\Typora\typora-user-images\image-20211006205124162.png)

블록 - 동기 : 언제 끝날지 속으로 신경쓰며 끝나기를 기다린다. 

블록-비동기 : 언제 끝날지 신경쓰지 않고 멍때리며 끝나기를 기다린다.

논블록-동기 : 본인 일을 보다가 다 끝나가는지 계속 물어본다. -- 필요이상의 cpu 자원낭비, I/O의 지연시간 초래 /polling

논블록-비동기 : 언제 끝날지 신경쓰지 않고 본인 할일 하다가 끝난 작업(callback)을 받는다.



블록-비동기

- 이점이 없어 사용을 하진 않지만, 의도치 않게 이 방식으로 동작하는 경우가 있다고 한다. 

- 논블록-비동기 방식에서 하나라도 blocking으로 동작한다면 블록-비동기 방식으로 진행

- 대표적인 예시로 Node.js - MySQL

  - MySQL에서 제공하는 드라이버가 blocking 방식이기 때문에

  - Node.js에서 Async로 접근해와도 결국 DB 작업 호출시에 해당 MySQL 드라이버를 호출

    

# **Blocking I/O**

1. 프로세스(thread)가 커널에게 I/O를 요청하는 함수를 호출

2. 커널이 작업을 완료하면 작업 결과를 반환 받음

   특징

   - I/O 작업이 진행되는 동안 프로세스는 자신의 작업을 중단한 채 대기

   - Resource 낭비가 심함 (I/O 작업이 cpu를 거의 쓰지 않으므로)

     



# **Non-Blocking I/O**

1. 프로세스가 recvfrom 함수 호출 (커널에게 해당 Socket으로부터 data를 받고 싶다고 요청함)
2. 커널은 이 요청에 대해 곧바로 recvBuffer을 채워서 보내지 못하므로 "EWOULDBLOCK"을 return함
3. Blocking 방식과 달리 프로세스는 다른 작업 할 수 있음
4. recvBuffer에 프로세스가 받을 수 있는 데이터가 있는 경우, buffer로부터 데이터를 복사하여 받아옴
5. recvfrom 함수는 빠른 속도로 데이터를 복사한 후, 복사한 데이터의 길이와 함께 반환

recv~ 데이터를 수신해주는 함수